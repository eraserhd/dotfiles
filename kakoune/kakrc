# General Settings
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

set-option global autoreload yes
set-option global grepcmd 'ag --column'

hook global BufWritePre .* %{ nop %sh{ mkdir -p $(dirname "$kak_hook_param") }}

alias global gn grep-next-match
alias global gp grep-previous-match

# Appearance
# ‾‾‾‾‾‾‾‾‾‾

colorscheme palenight

set-face global PrimarySelection default,rgb:8700af+g
set-face global SecondarySelection default,rgb:5f0087+g

set-option global ui_options ncurses_assistant=none ncurses_status_on_top=true ncurses_set_title=false
set-face global LineNumbersWrapped black
add-highlighter global/matching show-matching

hook global WinSetOption filetype=(?!tmux-copy).* %{
    try %{ add-highlighter window/number number-lines }
    try %{ add-highlighter window/whitespace show-whitespaces -spc ' ' -tab '➤' -lf '↩' }
}
hook global WinSetOption filetype=tmux-copy %{
    try %{ remove-highlighter window/number }
    try %{ remove-highlighter window/whitespace }
}

define-command highlight-trailing-whitespace %{
    evaluate-commands %sh{
        if [ -z "$kak_client" ]; then
            exit
        fi
        printf %s\\n 'try %{ remove-highlighter window/trailing-whitespace }'
        case "$kak_opt_filetype" in
        diff) printf %s\\n 'add-highlighter window/trailing-whitespace regex '"'"'^[^\n]+?\K\h+$'"'"' 0:default,rgb:ff5370+g' ;;
        *)    printf %s\\n 'add-highlighter window/trailing-whitespace regex '"'"'\h+$'"'"' 0:default,rgb:ff5370+g' ;;
        esac
    }
}

hook global WinSetOption filetype=.* %{
    hook -once window NormalIdle .* highlight-trailing-whitespace
}

# Stolen from mawww (and heavily modified!)
declare-option -hidden regex curword
declare-option -hidden regex curword_word_class
set-face global CurWord default,rgb:4a4a4a
add-highlighter global/ dynregex '%opt{curword}' 0:CurWord

define-command -override -hidden highlight-curword %{
    eval -draft %{
        try %{
            execute-keys <space><a-i>w
            set-option buffer curword "(?<!%opt{curword_word_class})\Q%val{selection}\E(?!%opt{curword_word_class})"
        } catch %{
            set-option buffer curword ''
        }
    }
}
define-command -override -hidden make-curword-word-class %{
    evaluate-commands %sh{
        eval set -- "$kak_quoted_opt_extra_word_chars"
        word_class='['
        while [ $# -ne 0 ]; do
            case "$1" in
                -) word_class="$word_class-";;
            esac
            shift
        done
        word_class="$word_class"'\w'
        eval set -- "$kak_quoted_opt_extra_word_chars"
        while [ $# -ne 0 ]; do
            case "$1" in
                "-") ;;
                "]") word_class="$word_class"'\]';;
                "'") word_class="$word_class''";;
                *)   word_class="$word_class$1";;
            esac
            shift
        done
        word_class="$word_class]"
        printf "set-option window curword_word_class '%s'\\n" "$word_class"
    }
}
hook -group highlight-curword global NormalIdle .* highlight-curword
hook -group highlight-curword global WinSetOption extra_word_chars=.* make-curword-word-class

define-command wrap %{
    add-highlighter window/wrap wrap -word -width 78
}

# System clipboard handling
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

define-command -override -hidden copy-snarf-to-dquote %{
    evaluate-commands %sh{
        snarf="$(9 9p read snarf/snarf && printf x)"
        if [ $? -ne 0 ]; then
            exit
        fi
        if [ ! "$snarf" = "${kak_main_reg_dquote}x" ]; then
            printf "set-register dquote '"
            printf %s "${snarf%x}" |sed -e "s/'/''/g"
            printf "'\n"
        fi
    }
}

declare-option -hidden str snarf_last_dquote
define-command -override -hidden copy-dquote-to-snarf %{
    evaluate-commands %sh{
        if [ ! "$kak_main_reg_dquote" = "$kak_opt_snarf_last_dquote" ]; then
            printf %s "$kak_main_reg_dquote" |9 9p write snarf/snarf
            printf "set-option global snarf_last_dquote '"
            printf %s "$kak_main_reg_dquote" |sed -e "s/'/''/g"
            printf "'\n"
        fi
    }
}

hook -group snarf global FocusIn .* copy-snarf-to-dquote
hook -group snarf global NormalIdle .* copy-dquote-to-snarf

# Soft tabs
# ‾‾‾‾‾‾‾‾‾

define-command -params 0 expand-tabs %{
    hook -group expand-tabs window InsertChar \t %{ try %{
        execute-keys -draft "h<a-h><a-k>\A\h+\z<ret><a-;>;%opt{indentwidth}@"
    } }
    hook -group expand-tabs window InsertDelete ' ' %{ try %{
        execute-keys -draft "h<a-h><a-k>\A\h+\z<ret>i<space><esc><lt>"
    } }
}

define-command -params 0 keep-tabs %{
    remove-hooks window expand-tabs
}

hook global WinSetOption filetype=(?!makefile).* expand-tabs
hook global WinSetOption filetype=makefile keep-tabs

# Find
# ‾‾‾‾

define-command -docstring 'Find a file' -params 1 -shell-script-candidates %{ag -l -f} -menu find %{ edit %arg{@} }

define-command -override -params 1 -shell-script-candidates %{
    dir="$(pwd)"
    if command -v mdfind >/dev/null; then
        mdfind -onlyin "${dir}/" / |sed -e 's,^'"${dir}"'/,,'
    else
        locate "${dir}/" |sed -e 's,^'"${dir}"'/,,'
    fi
} -menu f %{edit %arg{@}}

# Jump
# ‾‾‾‾

declare-option -hidden str jump_search_result

define-command -hidden -params 1 jump-helper %{
    evaluate-commands %sh{
        if [ "$1" -ef "${kak_buffile}" ]; then
            printf 'set-option global jump_search_result "%s"\n' "${kak_client}"
        fi
    }
}

define-command -override \
    -docstring %{jump [<options>] <file> [<line> [<column>]]

Takes all the same switches as edit.} \
    -params 1..3 \
    -file-completion \
    jump %{
    set-option global jump_search_result %opt{jumpclient}
    evaluate-commands %sh{
        for client in ${kak_client_list}; do
            echo "evaluate-commands -client \"${client}\" %{jump-helper \"$1\"}"
        done
    }
    evaluate-commands -try-client %opt{jump_search_result} %{
        edit %arg{@}
        try %{ focus }
    }
}

# Layout
# ‾‾‾‾‾‾

declare-option -hidden str-list tmux_client_info

define-command -hidden tmux-visit-client %{
    evaluate-commands %sh{
        if [ -n "${kak_client_env_TMUX}" ] && [ -n "${kak_client_env_TMUX_PANE}" ]; then
            printf 'set-option -add global tmux_client_info %%{%s} %%{%s} %%{%s}\n' "${kak_client}" "${kak_client_env_TMUX}" "${kak_client_env_TMUX_PANE}"
        fi
    }
}

define-command -hidden tmux-collect-client-info %{
    set-option global tmux_client_info
    evaluate-commands %sh{
        for client in ${kak_client_list}; do
            printf 'evaluate-commands -client "%s" tmux-visit-client\n' "${client}"
        done
    }
}

define-command update-client-options %{
    tmux-collect-client-info
    evaluate-commands %sh{
        toolsclient=
        toolsclient_left=-1
        toolsclient_top=999999

        # Best client for tools client is upper-righthand corner
        eval set -- "${kak_opt_tmux_client_info}"
        while [ $# -gt 0 ]; do
            client="$1"; shift
            TMUX="$1"; shift
            TMUX_PANE="$1"; shift
            export TMUX TMUX_PANE

            pane_position=$(tmux display-message -t "${TMUX_PANE}" -p -F '#{pane_top}.#{pane_left}')
            pane_top="${pane_position%.*}"
            pane_left="${pane_position#*.}"

            accept=no
            if [ $pane_left -gt $toolsclient_left ]; then
                accept=yes
            elif [ $pane_left -eq $toolsclient_left ] && [ $pane_top -lt $toolsclient_top ]; then
                accept=yes
            fi

            if [ $accept = yes ]; then
                toolsclient=$client
                toolsclient_left=$pane_left
                toolsclient_top=$pane_top
            fi
        done

        jumpclient=
        jumpclient_left=-1
        jumpclient_top=999999

        # Best client for jumpclient is just to left of toolsclient
        eval set -- "${kak_opt_tmux_client_info}"
        while [ $# -gt 0 ]; do
            client="$1"; shift
            TMUX="$1"; shift
            TMUX_PANE="$1"; shift
            export TMUX TMUX_PANE

            pane_position=$(tmux display-message -t "${TMUX_PANE}" -p -F '#{pane_top}.#{pane_left}')
            pane_top="${pane_position%.*}"
            pane_left="${pane_position#*.}"

            accept=no
            if [ $pane_left -lt $toolsclient_left ] && [ $pane_left -gt $jumpclient_left ]; then
                accept=yes
            elif [ $pane_left -eq $jumpclient_left ] && [ $pane_top -lt $jumpclient_top ]; then
                accept=yes
            fi

            if [ $accept = yes ]; then
                jumpclient=$client
                jumpclient_left=$pane_left
                jumpclient_top=$pane_top
            fi
        done

        # REPL pane is in the lower, right-hand corner
        repl_pane=
        repl_pane_left=-1
        repl_pane_top=-1
        tmux list-panes -F '#{pane_top} #{pane_left} #{pane_id}' | {
            while read pane_top pane_left pane_id; do
                accept=no
                if [ $pane_left -gt $repl_pane_left ]; then
                    accept=yes
                elif [ $pane_left -eq $repl_pane_left ] && [ $pane_top -gt $repl_pane_top ]; then
                    accept=yes
                fi

                if [ $accept = yes ]; then
                    repl_pane="$pane_id"
                    repl_pane_left=$pane_left
                    repl_pane_top=$pane_top
                fi
            done
            if [ -n "$repl_pane" ]; then
                printf 'set-option global tmux_repl_id %%{%s}\n' "$repl_pane"
            fi
        }

        if [ -n "$toolsclient" ]; then
            printf 'set-option global toolsclient "%s"\n' "$toolsclient"
        fi
        if [ -n "$jumpclient" ]; then
            printf 'set-option global jumpclient "%s"\n' "$jumpclient"
        fi
    }
}

hook -group client-tracker global FocusIn .* update-client-options
hook -group client-tracker global WinCreate .* update-client-options
hook -group client-tracker global WinClose .* update-client-options
hook -group client-tracker global WinResize .* update-client-options

# Normal Mode
# ‾‾‾‾‾‾‾‾‾‾‾

map global normal * '<a-i>w"/yn'
map global normal <a-*> '<a-i>w"/y<a-n>'

map global user c ': enter-user-mode case<ret>'

# Filetypes
# ‾‾‾‾‾‾‾‾‾

hook global WinSetOption filetype=nix %{
    set-option window indentwidth 2
}

hook -group wrap global WinSetOption filetype=asciidoc %{
    add-highlighter window/wrap -word
}
hook -group wrap global WinSetOption filetype=(?!asciidoc).* %{
    remove-highlighter window/wrap
}

# Clojure
# ‾‾‾‾‾‾‾
hook global WinSetOption filetype=(clojure|scheme|racket) %{
    parinfer-enable-window -smart
    require-module clojure
    set-option window clojure_source_directories '(?:[^/.][^/]*)(?:/src|/test|/dev)'
}

define-command -hidden -override lint-show-counters %{}

hook global WinSetOption filetype=clojure %{
    set-option window lintcmd 'cd "$(dirname "$kak_bufname")" && clj-kondo --lint'
    lint-enable
    hook -group lint-diagnostics window NormalIdle .* %{ lint; lint-show }
}

declare-option -hidden str clojure_buffer_contents
declare-option -hidden str-list clojure_selections

define-command -override -params 1 -docstring %{Clojure element} \
    clojure-select-object %{
    evaluate-commands -draft %{
        execute-keys '%'
        set-option buffer clojure_buffer_contents %val{selection}
    }
    set-option buffer clojure_selections
    evaluate-commands %sh{
        kind="$1"
        count="${kak_count-1}"
        result_selections=''
        for desc in $kak_selections_char_desc; do
            anchor_line="${desc%%.*}"
            desc="${desc#*.}"
            anchor_column="${desc%%,*}"
            desc="${desc#*,}"
            cursor_line="${desc%%.*}"
            cursor_column="${desc#*.}"
            extent=whole
            case "|${kak_object_flags}|" in
                *"|inner|"*) extent=inside;;
            esac
            direction=''
            case "${kak_object_flags}" in
                *to_begin*to_end*|*to_end*to_begin*) direction='';;
                *to_begin*) direction=to_begin;;
                *to_end*) direction=to_end;;
            esac
            if [ $cursor_line -lt $anchor_line ]; then
                dir=forward
            elif [ $cursor_line -eq $anchor_line ] && [ $cursor_column -lt $anchor_column ]; then
                dir=forward
            fi
            if [ "$dir" = forward ]; then
                cursor_column=$(( cursor_column - 1 ))
            else
                anchor_column=$(( anchor_column - 1 ))
            fi
            eval "$(rep --port="@.nrepl-port@${kak_buffile-.}" \
                --op=select \
                --send kind,string,$kind \
                --send count,integer,$count \
                --send combine,string,$kak_select_mode \
                --send direction,string,$direction \
                --send extent,string,$extent \
                --send cursor-line,integer,$cursor_line \
                --send cursor-column,integer,$cursor_column \
                --send anchor-line,integer,$anchor_line \
                --send anchor-column,integer,$anchor_column \
                --print cursor-line,1,ok=yes%ncursor_line=%{cursor-line}%ncursor_column=%{cursor-column}%nanchor_line=%{anchor-line}%nanchor_column=%{anchor-column}%n \
                --print out,2,%{out} \
                --print err,2,%{err} \
                --print value,2,%{value}%n \
                "$kak_opt_clojure_buffer_contents" )"
            if [ "$ok" = "yes" ]; then
                dir=''
                if [ $cursor_line -lt $anchor_line ]; then
                    dir=forward
                elif [ $cursor_line -eq $anchor_line ] && [ $cursor_column -lt $anchor_column ]; then
                    dir=forward
                fi
                if [ "$dir" = forward ]; then
                    cursor_column=$(( cursor_column + 1 ))
                else
                    anchor_column=$(( anchor_column + 1 ))
                fi
                result_selections="${result_selections} ${anchor_line}.${anchor_column},${cursor_line}.${cursor_column}"
            fi
        done
        printf 'select -codepoint %s\n' "$result_selections"
    }
}

hook -group clojure-objects global WinSetOption filetype=clojure %{
    set-option window indentwidth 2
    map -docstring 'Clojure element'        window object e '<a-;> clojure-select-object element<ret>'
    map -docstring 'Clojure form'           window object f '<a-;> clojure-select-object form<ret>'
    map -docstring 'top-level Clojure form' window object t '<a-;> clojure-select-object toplevel<ret>'

    map window normal b '[<a-;> clojure-select-object element<ret>'
    map window normal B '{<a-;> clojure-select-object element<ret>'
    map window normal e ']<a-;> clojure-select-object element<ret>'
    map window normal E '}<a-;> clojure-select-object element<ret>'
    map window normal w '<a-a><a-;> clojure-select-object element<ret>'
}

# Scheme
# ‾‾‾‾‾‾

hook -group scheme global WinSetOption filetype=scheme %{
    set-option window indentwidth 2
}

# Misc
# ‾‾‾‾

define-command rm %{
    nop %sh{ rm -f "$kak_buffile" }
    delete-buffer!
}

define-command \
    -override \
    -docstring %{mv <target>: move this file to <target> dir or file} \
    -shell-script-candidates %{ag -l -f} \
    -params 1 \
    mv %{
    evaluate-commands %sh{
        target="$1"
        if $kak_modified; then
            printf 'fail "mv: buffer is modified."\n'
            exit
        fi
        if [ -d "$target" ]; then
            target="${target}/$(basename "$kak_buffile")"
        fi
        mkdir -p "$(dirname "$target")"
        mv "$kak_buffile" "$target"
        if [ $? -ne 0 ]; then
            printf 'fail "mv: unable to move file."\n'
            exit
        fi
        printf 'delete-buffer\n'
        printf 'edit %%{%s}\n' "$target"
    }
}

# Git
# ‾‾‾

define-command \
    -override \
    -params 0 \
    git-browse-link %{
    evaluate-commands %sh{
        link=$(git browse-link "$kak_buffile" "$kak_selection_desc" 2>&1)
        if [ $? -ne 0 ]; then
            printf "fail '"
            printf "%s" "$link" |sed -e "s/'/''/g"
            printf "'\\n"
            exit
        fi
        printf "set-register '\"' '"
        printf "%s" "$link" |sed -e "s/'/''/g"
        printf "'\\n"
    }
}
