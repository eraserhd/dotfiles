#!/usr/bin/env gsi

(define (chomp s)
  (if (and (< 0 (string-length s))
           (char=? #\newline (string-ref s (- (string-length s) 1))))
    (substring s 0 (- (string-length s) 1))
    s))

(define (get-dom-property task-uuid property-path)
  (let ((dom-path (string-append task-uuid "." property-path)))
    (call-with-input-process `(path: "task"
                               arguments: ("_get" ,dom-path))
      (lambda (p)
        (chomp (list->string (read-all p read-char)))))))

(define (get-task task-uuid)
  `((uuid:        . ,task-uuid)
    (id:          . ,(get-dom-property task-uuid "id"));
    (project:     . ,(get-dom-property task-uuid "project"));
    (description: . ,(get-dom-property task-uuid "description"))))

(define (tasks-to-review)
  (with-input-from-process '(path: "task"
                             arguments: ("rc.report._reviewed.sort:project+"
                                         "_reviewed"))
    (lambda ()
      (let loop ((tasks '()))
        (let ((next (read-line)))
          (if (eof-object? next)
            (reverse tasks)
            (loop (cons (get-task next) tasks))))))))

(define last-project "")
(define (display-task task)
  (let ((project (cdr (assq project: task))))
    (if (not (string=? last-project project))
      (begin
        (newline)
        (display ">> ")
        (display project)
        (newline)
        (set! last-project project))))
  (display " [ ] ")
  (display (cdr (assq id: task)))
  (display " ")
  (display (cdr (assq description: task)))
  (newline))

(for-each display-task (tasks-to-review))

;
;(
;    for task_uuid in $(task rc.report._reviewed.sort:project+ _reviewed); do
;        task_id=$(task _get ${task_uuid}.id)
;    done
;)
