#!/usr/bin/env bash

set -e

readonly ANYCONNECT_PREFIX=/opt/cisco/anyconnect
readonly ONELOGIN_ITEM_ID=ok36jmwmuzf6pjjxmzzr64lxby

#-----------------------------------------------------------------------------
#                            ** 1Passowrd Helpers **
#-----------------------------------------------------------------------------

unlock1p() {
    if [ -e ~/.1password ]; then
        source ~/.1password
    fi
    if ! op get item "$ONELOGIN_ITEM_ID" >/dev/null 2>&1; then
        if ! op signin >~/.1password; then
            printf '2u: unlock failed.\n' >&2
            exit 1
        fi
        source ~/.1password
    fi
}

#-----------------------------------------------------------------------------
#                            ** OneLogin Helpers **
#-----------------------------------------------------------------------------

oneLoginUser() {
    op get item "$ONELOGIN_ITEM_ID" |jq -r '.details.fields[] | select(.designation == "username") | .value'
}

oneLoginPassword() {
    op get item "$ONELOGIN_ITEM_ID" |jq -r '.details.fields[] | select(.designation == "password") | .value'
}

oneLoginOTP() {
    op get totp "$ONELOGIN_ITEM_ID"
}

#-----------------------------------------------------------------------------
#                                  ** VPN **
#-----------------------------------------------------------------------------

cmd_vpn_usage() {
    printf '2u vpn: usage: `2u vpn { connect | disconnect }`\n'
    exit 1
}

readLineOrPartialLine() {
    local exitCode=0
    line=''
    read -t 1 line || exitCode=$?
    if (( exitCode != 0 && exitCode < 128 )); then
        return $exitCode
    fi
    if (( exitCode == 0 )); then
        line="$line"$'\n'
    fi
    return 0
}

makeTemporaryDirectory() {
    local dir="$(mktemp)"
    rm -f "$dir"
    mkdir -p "$dir"
    printf %s\\n "$dir"
}

# We unfortunately need to make an interactive sub-process for answering the
# prompts, since the hostscan can sometimes take a few minutes, invalidating
# our OTP.
#
# Further, the VPN client writes "secure" prompts directly to /dev/tty, so
# we need to find cues other than "Password:" and "Answer:"
vpnResponder() {
    local line
    while readLineOrPartialLine <&3; do
        printf %s "$line"
        case "$line" in
            *Username:*)
                oneLoginUser >&4
                oneLoginPassword >&4
                ;;
            *"Enter your one-time password"*)
                oneLoginOTP >&4
                ;;
            *accept"?"*)
                printf y\\n >&4
                ;;
        esac
    done
}

cmd_vpn_connect() {
    unlock1p
    local fifoDir="$(makeTemporaryDirectory)"
    mkfifo "${fifoDir}/vpn-in" "${fifoDir}/vpn-out"
    vpnResponder 3<"${fifoDir}/vpn-out" 4>"${fifoDir}/vpn-in" &
    local exitCode=0
    "$ANYCONNECT_PREFIX/bin/vpn" -s connect "2U Corp Network" >"${fifoDir}/vpn-out" 2>&1 <"${fifoDir}/vpn-in" || exitCode=$?
    rm -rf "$fifoDir"
    return $exitCode
}

cmd_vpn_disconnect() {
    "$ANYCONNECT_PREFIX/bin/vpn" disconnect "2U Corp Network"
}

cmd_vpn() {
    case "$1" in
    connect)    cmd_vpn_connect ;;
    disconnect) cmd_vpn_disconnect ;;
    *)          cmd_vpn_usage ;;
    esac
}

#-----------------------------------------------------------------------------
#                                ** Entry point **
#-----------------------------------------------------------------------------

main() {
    if [ -z "$1" ]; then
        printf '2u: usage is `2u subcommand [args ...]`\n' >&2
        exit 1
    fi

    command="$1"
    shift
    cmd_$command "$@"
}

main "$@"
